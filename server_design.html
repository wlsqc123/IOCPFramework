<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MMORPG 서버 아키텍처 설계 (상세 구현안)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Nordic Night -->
    <!-- Application Structure Plan: 사용자가 서버의 복잡한 구조를 쉽게 이해할 수 있도록 대시보드 스타일의 단일 페이지 애플리케이션(SPA)으로 설계했습니다. 좌측의 고정 사이드바 메뉴를 통해 '개요', '코어 아키텍처', '스레드 모델', '객체 관리', '네트워크 계층', '월드 관리', '성능 전략', '콘텐츠 구현 전략', '개발 계획' 등 주요 설계 파트를 자유롭게 탐색할 수 있습니다. 각 섹션은 텍스트 설명과 함께 다이어그램, 차트 등 시각적이고 상호작용 가능한 요소로 구성하여 정보 전달력을 높였습니다. 이러한 구조는 기술 포트폴리오 검토자가 짧은 시간 안에 프로젝트의 핵심 기술과 설계 사상을 파악하는 데 가장 효과적이라고 판단했습니다. -->
    <!-- Visualization & Content Choices: 
        - 개요: Goal(핵심 목표 전달), Method(강조된 텍스트 카드), Interaction(없음) -> 프로젝트의 핵심 목표를 명확히 각인.
        - 코어 아키텍처: Goal(세부 모듈 구조 이해), Method(HTML/CSS 다이어그램), Interaction(모듈 클릭 시 설명) -> 서버 내 매니저 클래스 단위의 유기적인 관계를 시각적으로 보여줌.
        - 스레드 모델: Goal(동시성 문제 해결 전략 제시), Method(순서도, 코드 예시), Interaction(없음) -> 액터 모델 기반 작업 큐잉 방식을 도입하여 복잡한 동시성 문제를 어떻게 명쾌하게 해결하는지 보여줌으로써 높은 수준의 설계 능력을 어필.
        - 객체 관리: Goal(상세 클래스 구조와 컴포넌트 디자인 이해), Method(확장된 HTML/CSS 클래스 다이어그램), Interaction(컴포넌트 클릭 시 설명) -> 최신 게임 서버 아키텍처 패턴(Component-based)에 대한 이해도를 어필하여 기술적 깊이를 증명.
        - 네트워크 계층: Goal(IOCP 및 패킷 구조 이해), Method(순서도 및 다이어그램), Interaction(단계별 호버) -> 비동기 네트워크 모델의 동작 방식과 실제 데이터 포맷을 구체적으로 제시.
        - 월드 관리: Goal(Quadtree 구현 방식 이해), Method(인터랙티브 시뮬레이션), Interaction(플레이어 생성, 영역 쿼리 시각화) -> 동적 공간 분할 기법을 시각적으로 증명하여 문제 해결 능력을 어필.
        - 성능 전략: Goal(최적화 기법 구체화), Method(Chart.js 그래프 및 코드 예시), Interaction(없음) -> 실제 코드 수준의 최적화 방법을 제시하여 기술 깊이를 증명.
        - 콘텐츠 구현 전략: Goal(핵심 콘텐츠의 기술적 구현 방안 제시), Method(순서도, 코드 예시, 설명, HTML/CSS 다이어그램), Interaction(없음) -> 거래, 전투, 채팅 등 MMORPG 핵심 콘텐츠를 어떤 자료구조와 알고리즘, 동시성 처리 모델을 통해 안정적으로 구현할 것인지 구체적으로 서술.
        - 개발 계획: Goal(체계적인 프로젝트 관리 능력 어필), Method(주차별 상세 업무 테이블), Interaction(없음) -> 3개월간의 마일스톤을 구체적으로 제시하여 실현 가능성과 계획성을 강조.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; background-color: #2E3440; color: #D8DEE9; }
        .nord-bg { background-color: #2E3440; }
        .nord-bg-light { background-color: #3B4252; }
        .nord-bg-lighter { background-color: #434C5E; }
        .nord-border { border-color: #4C566A; }
        .nord-text { color: #ECEFF4; }
        .nord-text-dim { color: #D8DEE9; }
        .nord-accent-blue { color: #88C0D0; }
        .nord-accent-green { color: #A3BE8C; }
        .nord-accent-red { color: #BF616A; }
        .nord-accent-yellow { color: #EBCB8B; }

        .sidebar-link { transition: all 0.2s ease-in-out; border-left: 3px solid transparent; }
        .sidebar-link:hover, .sidebar-link.active { background-color: #434C5E; color: #ECEFF4; border-left-color: #88C0D0; }
        .content-section { display: none; }
        .content-section.active { display: block; }
        
        .module-column { border: 1px solid #4C566A; border-radius: 0.5rem; padding: 1rem; }
        .manager-box { border: 1px dashed #5E81AC; background-color: #434C5E; padding: 0.75rem; border-radius: 0.25rem; cursor: pointer; text-align: center; }
        .manager-box:hover { background-color: #4C566A; }
        
        .flowchart-step { position: relative; border: 1px dashed #4C566A; background-color: #3B4252; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer; text-align: center;}
        .flowchart-arrow { position: relative; text-align: center; font-size: 2rem; color: #88C0D0; margin: 0.5rem 0; }
        
        .quadtree-canvas { background-color: #3B4252; position: relative; overflow: hidden; border-radius: 0.5rem; }
        .quadtree-boundary { position: absolute; border: 1px solid #4C566A; box-sizing: border-box; }
        .quadtree-point { position: absolute; width: 8px; height: 8px; background-color: #EBCB8B; border-radius: 50%; transform: translate(-50%, -50%); }
        .query-range { position: absolute; background-color: rgba(163, 190, 140, 0.2); border: 1px dashed #A3BE8C; box-sizing: border-box; }
        .point-in-range { background-color: #A3BE8C; box-shadow: 0 0 8px #A3BE8C; }

        .code-block { background-color: #272B35; border-radius: 0.5rem; padding: 1rem; font-family: 'Courier New', Courier, monospace; font-size: 0.875rem; overflow-x: auto; }
        .code-block .keyword { color: #81A1C1; }
        .code-block .type { color: #8FBCBB; }
        .code-block .comment { color: #616E88; }
        .code-block .literal { color: #B48EAD; }

        .plan-week { background-color: #3B4252; padding: 1rem; border-radius: 0.5rem; }
        .plan-task { margin-left: 1rem; padding-left: 1rem; border-left: 2px solid #4C566A; }
        
        .class-box { border: 1px solid #8FBCBB; background-color: #434C5E; padding: 0.5rem; border-radius: 0.25rem; cursor: pointer;}
        .class-box h4 { font-weight: bold; color: #ECEFF4; }
        .class-box ul { list-style: none; padding: 0; margin-top: 0.5rem; font-size: 0.8rem; }
        .class-box ul li { color: #D8DEE9; }

        .component-box { border: 1px dashed #A3BE8C; background-color: #434C5E; padding: 0.5rem; border-radius: 0.25rem; font-size: 0.9rem; text-align: center; cursor: pointer; }
        .component-box:hover { background-color: #4C566A; }
        .content-card { background-color: #3B4252; border-left: 4px solid #88C0D0; padding: 1.5rem; border-radius: 0.5rem; }
        .hit-detection-diagram { position: relative; width: 100%; max-width: 400px; height: 300px; background-color: #2E3440; border: 1px solid #4C566A; margin: auto; }
        .diagram-obj { position: absolute; border-radius: 50%; }
        .caster { width: 20px; height: 20px; background-color: #88C0D0; }
        .target { width: 15px; height: 15px; background-color: #BF616A; }
        .target.hit { background-color: #A3BE8C; box-shadow: 0 0 8px #A3BE8C; }
        .aoe-range { position: absolute; border: 2px dashed #EBCB8B; border-radius: 50%; background-color: rgba(235, 203, 139, 0.1); }
        .quad-node { position: absolute; border: 1px dotted rgba(94, 129, 172, 0.5); box-sizing: border-box; }
    </style>
</head>
<body class="nord-bg">
    <div class="flex h-screen">
        <aside id="sidebar" class="w-64 nord-bg-light flex-shrink-0 p-4 transition-all duration-300">
            <h1 class="text-2xl font-bold nord-text mb-6">서버 설계</h1>
            <nav id="nav-menu">
                <a href="#" data-section="overview" class="sidebar-link active block py-2.5 px-4 rounded">개요</a>
                <a href="#" data-section="architecture" class="sidebar-link block py-2.5 px-4 rounded">코어 아키텍처</a>
                <a href="#" data-section="threading" class="sidebar-link block py-2.5 px-4 rounded">스레드 모델</a>
                <a href="#" data-section="objects" class="sidebar-link block py-2.5 px-4 rounded">객체 관리</a>
                <a href="#" data-section="network" class="sidebar-link block py-2.5 px-4 rounded">네트워크 계층</a>
                <a href="#" data-section="world" class="sidebar-link block py-2.5 px-4 rounded">월드 관리</a>
                <a href="#" data-section="performance" class="sidebar-link block py-2.5 px-4 rounded">성능 전략</a>
                <a href="#" data-section="content" class="sidebar-link block py-2.5 px-4 rounded font-bold">콘텐츠 구현 전략</a>
                <a href="#" data-section="plan" class="sidebar-link block py-2.5 px-4 rounded">개발 계획</a>
            </nav>
        </aside>
        
        <main class="flex-1 p-6 lg:p-10 overflow-y-auto">
            <section id="overview" class="content-section active">
                 <h2 class="text-3xl font-bold nord-accent-blue mb-4">고성능 MMORPG 서버 설계</h2>
                <p class="text-lg nord-text-dim mb-8">본 문서는 C++23을 기반으로 Windows IOCP 모델을 사용하여 10,000명 이상의 동시 접속자를 처리할 수 있는 고성능 MMORPG 서버 설계를 제안합니다. 높은 처리량과 안정성을 핵심 목표로 하며, 3개월 내 개발 완료를 위한 구체적인 아키텍처와 전략을 포함합니다.</p>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div class="nord-bg-light p-6 rounded-lg shadow-lg"><h3 class="text-xl font-bold nord-accent-green mb-2">동시 접속자 목표</h3><p class="text-3xl font-bold nord-text">10,000+</p><p class="nord-text-dim mt-2">안정적인 대규모 사용자 수용</p></div>
                    <div class="nord-bg-light p-6 rounded-lg shadow-lg"><h3 class="text-xl font-bold nord-accent-yellow mb-2">핵심 기술</h3><p class="text-3xl font-bold nord-text">C++23 & IOCP</p><p class="nord-text-dim mt-2">최신 표준과 고성능 I/O 모델</p></div>
                    <div class="nord-bg-light p-6 rounded-lg shadow-lg"><h3 class="text-xl font-bold nord-accent-red mb-2">주요 특징</h3><p class="text-3xl font-bold nord-text">높은 처리량</p><p class="nord-text-dim mt-2">Lock-Free 및 최적화 기법 적용</p></div>
                </div>
            </section>

            <section id="architecture" class="content-section">
                <h2 class="text-3xl font-bold nord-accent-blue mb-4">코어 아키텍처 (상세 모듈)</h2>
                <p class="text-lg nord-text-dim mb-8">서버는 기능별 책임이 명확한 관리자(Manager) 클래스들의 집합으로 구성됩니다. 이들은 '스레드 모델' 섹션에서 설명할 작업 큐잉 시스템을 통해 상호작용하며 전체 게임 로직을 완성합니다.</p>
                <div class="nord-bg-light p-8 rounded-lg">
                    <h3 class="text-xl font-bold text-center mb-6 nord-text">Game Server Process</h3>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                        <div class="module-column">
                            <h4 class="font-bold text-center mb-4 nord-accent-blue">I/O & Dispatch</h4>
                            <div class="space-y-3">
                                <div class="manager-box clickable-module" data-info="IOCP 모델을 총괄하며 클라이언트 접속 수락 및 I/O 완료 이벤트를 처리합니다.">Network Manager</div>
                                <div class="manager-box clickable-module" data-info="연결된 각 클라이언트의 세션을 관리합니다. I/O 작업의 주체입니다.">Session Manager</div>
                                <div class="manager-box clickable-module" data-info="수신된 패킷을 분석하여 어떤 객체(Player, Party 등)의 작업인지 판단하고, 해당 객체의 작업 큐에 Job을 넣어주는 디스패처 역할을 합니다.">Packet Handler</div>
                            </div>
                        </div>
                        <div class="module-column">
                            <h4 class="font-bold text-center mb-4 nord-accent-green">Logic & World</h4>
                            <div class="space-y-3">
                                <div class="manager-box clickable-module" data-info="모든 Player 객체의 생성, 소멸, 검색을 담당합니다.">Player Manager</div>
                                <div class="manager-box clickable-module" data-info="게임 월드(Quadtree)와 그 안의 모든 객체(Creature)의 동기화를 관리합니다.">World Manager</div>
                                 <div class="manager-box clickable-module" data-info="파티, 길드 등 여러 플레이어가 상호작용하는 콘텐츠의 로직을 처리합니다. 각 파티/길드 역시 고유의 작업 큐를 가집니다.">Contents Manager</div>
                            </div>
                        </div>
                        <div class="module-column">
                            <h4 class="font-bold text-center mb-4 nord-accent-yellow">Data & Services</h4>
                            <div class="space-y-3">
                                <div class="manager-box clickable-module" data-info="아이템, 스킬 등의 원본 데이터를 관리하는 데이터 시트(Data Sheet)를 로드하고 접근을 제공합니다.">Data Manager</div>
                                <div class="manager-box clickable-module" data-info="DB와의 모든 통신을 담당합니다. 비동기 쿼리 실행 후, 결과 처리를 위한 Job을 생성하여 원래 요청했던 객체의 큐에 넣어줍니다.">DB Manager (MySQL)</div>
                                <div class="manager-box clickable-module" data-info="서버의 상태 로깅 및 각종 유틸리티 기능을 제공합니다.">Service Manager</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="architecture-info" class="mt-6 p-4 nord-bg-lighter rounded-lg min-h-[80px] text-center transition-opacity duration-300 opacity-0"><p class="nord-text-dim">모듈을 클릭하여 상세 정보를 확인하세요.</p></div>
            </section>

            <section id="threading" class="content-section">
                <h2 class="text-3xl font-bold nord-accent-blue mb-4">스레드 모델: 액터 기반 작업 큐잉</h2>
                <p class="text-lg nord-text-dim mb-8">
                    다중 스레드 환경에서 발생하는 복잡한 동시성 문제를 해결하기 위해, 각 플레이어와 같은 핵심 객체가 자신만의 작업 큐를 갖는 모델을 채택합니다. 이를 통해 객체 내부 데이터에 대한 Lock을 완전히 제거하여 코드 복잡도를 낮추고 성능을 향상시킵니다.
                </p>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 items-start">
                    <div>
                        <h3 class="text-xl font-bold mb-4 nord-text">작업 처리 흐름</h3>
                        <div class="flex flex-col items-center space-y-1 text-sm nord-bg-light p-4 rounded-lg">
                            <div class="flowchart-step">I/O 스레드 (IOCP)</div>
                            <div class="flowchart-arrow">↓ <span class="text-xs nord-text-dim">(Packet 수신)</span></div>
                            <div class="flowchart-step">Packet Handler (디스패처)</div>
                             <div class="flowchart-arrow">↓ <span class="text-xs nord-text-dim">(Player ID 기반으로 큐 선택)</span></div>
                            <div class="flowchart-step w-full">
                                Player A의 Job Queue
                                <div class="text-xs nord-text-dim">[Job1][Job2]...</div>
                            </div>
                             <div class="flowchart-arrow">↓ <span class="text-xs nord-text-dim">(순서대로 처리)</span></div>
                            <div class="flowchart-step">로직 스레드</div>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-bold mb-4 nord-text">핵심 구현 아이디어</h3>
                        <p class="text-sm nord-text-dim mb-4">
                            모든 로직은 `Job`이라는 단위로 추상화됩니다. `Player`는 `IJobQueue` 인터페이스를 구현하여 자신만의 작업 큐를 소유합니다.
                        </p>
                         <div class="code-block mb-4">
                            <pre><code><span class="keyword">class</span> <span class="type">Job</span> {
<span class="keyword">public</span>:
  <span class="keyword">virtual</span> <span class="type">void</span> <span class="literal">Execute</span>() = 0;
};

<span class="keyword">class</span> <span class="type">Player</span> : <span class="keyword">public</span> Creature, <span class="keyword">public</span> IJobQueue {
<span class="keyword">public</span>:
  <span class="comment">// Job을 자신의 큐에 넣는다.</span>
  <span class="type">void</span> <span class="literal">Push</span>(Job* job) { m_jobs.<span class="literal">Push</span>(job); }
<span class="keyword">private</span>:
  LockFreeQueue&lt;Job*&gt; m_jobs;
};</code></pre>
                        </div>
                        <h4 class="font-bold nord-text">장점:</h4>
                        <ul class="list-disc list-inside text-sm nord-text-dim">
                            <li><strong>Lock-Free 로직:</strong> 플레이어의 인벤토리, 스탯 등을 수정할 때 뮤텍스 락이 필요 없습니다.</li>
                            <li><strong>순서 보장:</strong> 한 플레이어의 모든 요청은 도착한 순서대로 처리됩니다.</li>
                            <li><strong>명확한 설계:</strong> 코드의 흐름이 '이벤트 발생 -> Job 생성 -> 큐에 Push'로 단순화됩니다.</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section id="objects" class="content-section">
                <h2 class="text-3xl font-bold nord-accent-blue mb-4">객체 관리: 컴포넌트 기반 설계</h2>
                <p class="text-lg nord-text-dim mb-8">복잡한 상속 구조 대신, 기능 단위의 **컴포넌트**를 조립하여 객체를 구성합니다. 이 방식은 코드의 재사용성과 확장성을 극대화합니다. 각 컴포넌트 박스를 클릭하여 역할을 확인해보세요.</p>
                <div class="nord-bg-light p-6 rounded-lg">
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <div class="class-box">
                            <h4>Creature (Base Object)</h4>
                            <ul>
                                <li>ObjectID m_id</li>
                                <li>ObjectType m_type</li>
                                <li><strong>IJobQueue* m_ownerQueue</strong></li>
                                <li>virtual void Update()</li>
                            </ul>
                            <hr class="my-2 nord-border">
                            <div class="grid grid-cols-2 gap-2 mt-2">
                                <div class="component-box" data-info="HP, MP, 공격력, 방어력 등 모든 스탯 정보와 관련 계산 로직을 담당합니다.">StatComponent</div>
                                <div class="component-box" data-info="월드 내 좌표(x, y, z), 방향 등 위치 정보를 관리합니다.">PositionComponent</div>
                                <div class="component-box" data-info="Idle, Move, Attack, Dead 등 객체의 현재 상태와 상태 전이를 관리하는 FSM(Finite State Machine)을 포함합니다.">StateComponent</div>
                                <div class="component-box" data-info="스킬 사용, 데미지 판정, 버프/디버프 적용 등 전투 관련 로직을 처리합니다.">CombatComponent</div>
                            </div>
                        </div>
                        <div class="space-y-4">
                            <div class="class-box">
                                <h4>Player : public Creature</h4>
                                <ul>
                                    <li>GameSession* m_session</li>
                                    <li><strong>LockFreeQueue&lt;Job*&gt; m_jobQueue</strong></li>
                                </ul>
                                <hr class="my-2 nord-border">
                                <div class="grid grid-cols-2 gap-2 mt-2">
                                    <div class="component-box" data-info="플레이어의 소지품 목록과 아이템 사용/획득/버리기 로직을 담당합니다.">InventoryComponent</div>
                                    <div class="component-box" data-info="플레이어가 습득한 스킬 목록과 쿨타임 등을 관리합니다.">SkillComponent</div>
                                    <div class="component-box" data-info="수행 중인 퀘스트의 목록과 진행 상태를 관리합니다.">QuestComponent</div>
                                </div>
                            </div>
                            <div class="class-box">
                                <h4>Monster : public Creature</h4>
                                <ul>
                                    <li>MonsterData m_monsterData</li>
                                </ul>
                                <hr class="my-2 nord-border">
                                <div class="grid grid-cols-2 gap-2 mt-2">
                                    <div class="component-box" data-info="몬스터의 행동 패턴(순찰, 추적, 공격)을 결정하는 AI 로직을 담고 있습니다.">AIComponent</div>
                                    <div class="component-box" data-info="몬스터가 죽었을 때 어떤 아이템을 어떤 확률로 드랍할지 결정하는 로직을 담당합니다.">LootComponent</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="component-info" class="mt-6 p-4 nord-bg-lighter rounded-lg min-h-[80px] text-center transition-opacity duration-300 opacity-0"><p class="nord-text-dim">컴포넌트를 클릭하여 상세 정보를 확인하세요.</p></div>
            </section>

            <section id="network" class="content-section">
                 <h2 class="text-3xl font-bold nord-accent-blue mb-4">네트워크 계층: IOCP와 패킷 구조</h2>
                <p class="text-lg nord-text-dim mb-8">안정적인 통신을 위해 명확한 패킷 구조를 정의합니다. 모든 패킷은 고정 크기의 헤더와 가변 크기의 바디로 구성됩니다. 헤더에는 패킷의 전체 크기와 종류를 식별하는 ID가 포함됩니다.</p>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <div>
                        <h3 class="text-xl font-bold mb-4 nord-text">패킷 구조</h3>
                        <div class="flex border-2 nord-border rounded-lg">
                            <div class="p-4 border-r-2 nord-border text-center flex-shrink-0">
                                <p class="font-bold">Header (4 bytes)</p>
                                <div class="flex mt-2">
                                    <div class="border nord-border p-2 w-24">Size (2B)</div>
                                    <div class="border nord-border p-2 w-24">ID (2B)</div>
                                </div>
                            </div>
                            <div class="p-4 text-center flex-grow">
                                <p class="font-bold">Body (가변)</p>
                                <div class="border nord-border p-2 mt-2 h-12 flex items-center justify-center">
                                    <p class="nord-text-dim">Serialized Data...</p>
                                </div>
                            </div>
                        </div>
                         <ul class="mt-4 space-y-2 text-sm">
                            <li><strong>Size (2 bytes):</strong> 헤더를 포함한 패킷 전체의 크기. TCP의 스트림 특성상 패킷의 경계를 구분하는 데 사용됩니다.</li>
                            <li><strong>ID (2 bytes):</strong> 패킷의 종류를 식별하는 고유 번호. (예: 101-로그인 요청, 201-이동 요청)</li>
                            <li><strong>Body (Variable):</strong> 실제 데이터. Protobuf, MessagePack 등으로 직렬화된 데이터가 위치합니다.</li>
                        </ul>
                    </div>
                    <div>
                        <h3 class="text-xl font-bold mb-4 nord-text">IOCP 처리 흐름</h3>
                        <div class="flex flex-col items-center space-y-1 text-sm">
                            <div class="flowchart-step" title="서버 소켓이 클라이언트의 연결 요청을 수락하고, 해당 클라이언트와 통신할 새로운 소켓을 생성합니다.">클라이언트 접속</div>
                            <div class="flowchart-arrow">↓</div>
                            <div class="flowchart-step" title="생성된 소켓을 IOCP 객체에 연결하고, 비동기 데이터 수신(Receive) 작업을 요청합니다. 작업이 즉시 완료되지 않고 백그라운드에서 진행됩니다.">IOCP 등록 & Recv 요청</div>
                            <div class="flowchart-arrow">↓</div>
                            <div class="flowchart-step" title="미리 생성된 워커 스레드 풀은 IOCP 큐를 감시합니다. I/O 작업(예: 데이터 수신)이 완료되면 OS가 큐에 완료 신호를 보냅니다.">I/O 스레드 대기</div>
                            <div class="flowchart-arrow">↓</div>
                            <div class="flowchart-step" title="대기하던 I/O 스레드가 깨어나 완료된 작업을 처리합니다. 수신된 데이터를 파싱하여 Job으로 만들고 해당 객체의 큐에 넣습니다.">Job 생성 및 분배</div>
                            <div class="flowchart-arrow">↓</div>
                            <div class="flowchart-step" title="로직 스레드가 해당 Job을 순서대로 실행하고, 응답이 필요하면 다시 I/O 스레드에 Send 요청을 보냅니다.">로직 스레드 Job 처리</div>
                        </div>
                    </div>
                </div>
            </section>

            <section id="world" class="content-section">
                <h2 class="text-3xl font-bold nord-accent-blue mb-4">월드 관리: Quadtree 공간 분할</h2>
                <p class="text-lg nord-text-dim mb-8">
                    고정 그리드 방식의 단점을 보완하기 위해 <strong>Quadtree</strong>를 사용합니다. Quadtree는 객체의 밀도에 따라 공간을 동적으로 분할하는 트리 자료구조입니다. 객체가 밀집된 지역은 더 잘게 분할하여 탐색 효율을 높이고, 객체가 없는 넓은 지역은 분할하지 않아 메모리를 절약합니다. 아래 시뮬레이션에서 마우스를 움직여 특정 영역의 객체를 쿼리하는 과정을 확인해보세요.
                </p>
                <div class="w-full max-w-3xl mx-auto">
                    <div class="flex justify-center space-x-4 mb-4">
                        <button id="quadtree-sim-btn" class="px-4 py-2 nord-bg-lighter rounded-lg hover:bg-nord-accent-blue hover:text-gray-800 transition">시뮬레이션 재시작</button>
                         <p class="p-2 text-sm text-center nord-text-dim">플레이어 수: <span id="player-count">0</span></p>
                    </div>
                    <div id="quadtree-canvas" class="quadtree-canvas w-full h-96 md:h-[500px] border-2 nord-border"></div>
                </div>
            </section>

            <section id="performance" class="content-section">
                 <h2 class="text-3xl font-bold nord-accent-blue mb-4">핵심 성능 전략: 구체적 기법</h2>
                <p class="text-lg nord-text-dim mb-8">높은 처리량 달성을 위한 구체적인 C++ 최적화 기법입니다. 이론뿐만 아니라 실제 코드 수준에서의 적용을 고려합니다.</p>
                <div class="chart-container w-full max-w-3xl mx-auto h-96 nord-bg-light p-4 rounded-lg mb-8">
                    <canvas id="performanceChart"></canvas>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-xl font-bold nord-text mb-2">Lock-Free 자료구조</h3>
                        <p class="text-sm mb-4 nord-text-dim">스레드 간 작업 공유를 위한 Job Queue는 C++20 `std::atomic`을 활용한 Lock-Free 큐로 구현하여 경합을 최소화합니다.</p>
                        <div class="code-block">
                            <pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">class</span> <span class="type">LockFreeQueue</span> {
<span class="keyword">public</span>:
  <span class="type">void</span> <span class="literal">Push</span>(T* data);
  T* <span class="literal">Pop</span>();
<span class="keyword">private</span>:
  <span class="comment">// ABA Problem 해결을 위한 포인터 태깅 등</span>
  std::atomic&lt;Node*&gt; m_head;
  std::atomic&lt;Node*&gt; m_tail;
};</code></pre>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-bold nord-text mb-2">메모리 풀링 (Object Pool)</h3>
                        <p class="text-sm mb-4 nord-text-dim">Player, Monster, Component, Job 등 모든 객체를 미리 할당하고 재사용하여 동적 메모리 할당으로 인한 부하와 단편화를 방지합니다.</p>
                        <div class="code-block">
                            <pre><code><span class="comment">// Job 객체를 풀에서 가져와 초기화</span>
MoveJob* job = ObjectPool&lt;MoveJob&gt;.<span class="literal">Acquire</span>();
job-&gt;<span class="literal">Init</span>(playerId, dest);

<span class="comment">// Player의 큐에 넣기</span>
player-&gt;<span class="literal">Push</span>(job);</code></pre>
                        </div>
                    </div>
                </div>
            </section>
            
            <section id="content" class="content-section">
                <h2 class="text-3xl font-bold nord-accent-blue mb-4">콘텐츠 구현 전략</h2>
                <p class="text-lg nord-text-dim mb-8">
                    성공적인 MMORPG 서버는 견고한 아키텍처 위에 핵심적인 게임 콘텐츠를 안정적으로 구현해야 합니다. 여기서는 거래, 전투, 채팅 등 주요 콘텐츠의 기술적 구현 방안을 구체적으로 서술합니다.
                </p>
                <div class="space-y-8">
                    <div class="content-card">
                        <h3 class="text-xl font-bold nord-text mb-2">1. 안전한 아이템 거래 (트랜잭션 보장)</h3>
                        <p class="mb-4 nord-text-dim"><strong>목표:</strong> 거래 도중 한쪽 플레이어의 접속이 끊기거나 서버가 다운되어도 아이템이 복사되거나 사라지지 않는 거래의 원자성(Atomicity)을 보장합니다.</p>
                        <h4 class="font-bold nord-accent-green mb-2">구현 방안: 2단계 커밋 (Two-Phase Commit) 유사 모델 적용</h4>
                        <p class="mb-4 nord-text-dim">액터 모델의 메시지 패싱을 이용하여 중앙 관리자(`TradeManager`) 없이 두 플레이어 객체 간의 상태를 동기화하며 거래를 진행합니다. 모든 단계는 각 플레이어의 Job Queue에 순차적으로 쌓여 처리되므로 안전합니다.</p>
                        <ol class="list-decimal list-inside nord-text-dim space-y-2 text-sm">
                            <li><strong>1단계 (Prepare):</strong> 양쪽 플레이어가 거래창에 아이템을 올리고 'Lock' 버튼을 누릅니다.
                                <ul class="list-disc list-inside ml-4">
                                    <li>서버는 각 플레이어에게 `PrepareTradeJob`을 큐에 넣습니다.</li>
                                    <li>`PrepareTradeJob` 실행 시, 서버는 각 플레이어가 실제 아이템을 소유했는지, 인벤토리에 공간이 있는지 검증하고 거래 상태를 'Locked'로 변경합니다. 검증 실패 시 거래는 즉시 취소됩니다.</li>
                                </ul>
                            </li>
                            <li><strong>2단계 (Commit):</strong> 양쪽 모두 'Locked' 상태에서 최종 'Confirm' 버튼을 누릅니다.
                                 <ul class="list-disc list-inside ml-4">
                                    <li>먼저 누른 쪽의 `CommitTradeJob`이 상대방에게 '나도 동의했음'을 알리는 이벤트를 보냅니다.</li>
                                    <li>상대방도 'Confirm'을 누르면, 양쪽 플레이어의 `CommitTradeJob`이 실행되면서 실제 아이템 소유권을 교환하는 로직이 각자의 `InventoryComponent`에서 실행됩니다.</li>
                                    <li>한쪽이라도 거래를 취소하거나 오프라인이 되면, 'Rollback' Job이 실행되어 거래를 원상 복구합니다.</li>
                                </ul>
                            </li>
                        </ol>
                    </div>

                    <div class="content-card">
                        <h3 class="text-xl font-bold nord-text mb-2">2. 실시간 전투 판정: 피격 로직</h3>
                        <p class="mb-4 nord-text-dim"><strong>목표:</strong> 다수의 플레이어가 참여하는 전투 상황에서도 빠르고 일관적인 판정을 제공합니다. 모든 판정은 서버 권위적으로 이루어지며, 스킬 타입에 따라 최적화된 로직을 사용합니다.</p>
                        
                        <div class="space-y-6">
                            <div>
                                <h4 class="font-bold nord-accent-green">A. 타겟 지정 스킬 (예: 파이어볼)</h4>
                                <p class="text-sm nord-text-dim">가장 간단한 형태로, 클라이언트가 지정한 대상에 대해 유효성 검사 후 즉시 결과를 적용합니다.</p>
                                <ol class="text-xs list-decimal list-inside mt-2">
                                    <li>클라이언트가 `S_SKILL_CAST (targetId: 123)` 요청</li>
                                    <li>서버: 시전자의 `SkillCastJob` 실행</li>
                                    <li>잡 내부: 거리, 시야, 쿨타임, 마나 등 조건 검사</li>
                                    <li>검사 통과 시: 대상(ID: 123)의 `CombatComponent`에 데미지 적용</li>
                                    <li>결과를 주변 플레이어에게 브로드캐스트</li>
                                </ol>
                            </div>

                            <div>
                                <h4 class="font-bold nord-accent-green">B. 범위 스킬 (AoE, Area of Effect) (예: 메테오)</h4>
                                <p class="text-sm nord-text-dim">특정 영역 내의 모든 유효 대상을 찾아 판정해야 하므로, Quadtree를 활용한 공간 탐색 최적화가 필수적입니다.</p>
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 items-center">
                                    <div>
                                        <ol class="text-xs list-decimal list-inside">
                                            <li>클라이언트가 `S_SKILL_CAST (position: x, y)` 요청</li>
                                            <li>서버: 시전자의 `SkillCastJob` 실행</li>
                                            <li>잡 내부: `WorldManager`에 특정 위치(x,y)와 반경(r)을 전달하여 **Quadtree 범위 쿼리** 요청</li>
                                            <li>Quadtree는 스킬 범위와 겹치는 노드들만 탐색하여 1차 후보군을 빠르게 반환</li>
                                            <li>서버는 후보군 객체들에 대해서만 정확한 거리 계산(원/부채꼴/사각형 판정) 및 유효성(아군/적군) 검사</li>
                                            <li>최종 피격 대상들에게만 데미지 적용 및 결과 브로드캐스트</li>
                                        </ol>
                                    </div>
                                    <div class="hit-detection-diagram">
                                        <!-- Quadtree Nodes -->
                                        <div class="quad-node" style="left:0; top:0; width:50%; height:50%;"></div>
                                        <div class="quad-node" style="left:50%; top:0; width:50%; height:50%;"></div>
                                        <div class="quad-node" style="left:0; top:50%; width:50%; height:50%;"></div>
                                        <div class="quad-node" style="left:50%; top:50%; width:50%; height:50%;"></div>
                                        <!-- Caster and Targets -->
                                        <div class="diagram-obj caster" style="left: 190px; top: 140px;" title="Caster"></div>
                                        <div class="diagram-obj target" style="left: 120px; top: 100px;"></div>
                                        <div class="diagram-obj target" style="left: 250px; top: 80px;"></div>
                                        <div class="diagram-obj target hit" style="left: 200px; top: 200px;"></div>
                                        <div class="diagram-obj target hit" style="left: 150px; top: 160px;"></div>
                                        <div class="diagram-obj target" style="left: 50px; top: 250px;"></div>
                                        <!-- AoE Range -->
                                        <div class="aoe-range" style="left: 120px; top: 70px; width: 160px; height: 160px;"></div>
                                        <p class="text-xs text-center absolute bottom-1 w-full nord-text-dim">Quadtree로 탐색 범위를 좁힌 후, 원 안에 있는 대상만 최종 판정</p>
                                    </div>
                                </div>
                            </div>

                            <div>
                                <h4 class="font-bold nord-accent-green">C. 투사체 스킬 (Projectile) (예: 얼음 화살)</h4>
                                <p class="text-sm nord-text-dim">시간에 따라 이동하는 객체를 생성하고, 매 프레임(Tick)마다 충돌을 검사합니다. 플레이어가 보고 피할 수 있는 여지를 줍니다.</p>
                                 <ol class="text-xs list-decimal list-inside mt-2">
                                    <li>클라이언트가 `S_SKILL_CAST (direction: dx, dy)` 요청</li>
                                    <li>서버: `Object Pool`에서 `Projectile` 객체를 하나 `Acquire`하여 월드에 생성</li>
                                    <li>`Projectile` 객체는 자신의 `Update()` 함수를 통해 매 서버 틱마다 앞으로 전진</li>
                                    <li>전진할 때마다 자신의 현재 위치 주변을 **작은 범위로 Quadtree에 쿼리**하여 충돌 후보군 탐색</li>
                                    <li>후보군과 실제 충돌(Bounding Box/Sphere 검사)이 발생하면, 대상에게 데미지를 적용하고 `Projectile` 객체는 소멸(`Release`되어 풀에 반납)</li>
                                    <li>최대 사거리에 도달하거나 수명이 다해도 자동 소멸</li>
                                </ol>
                            </div>
                        </div>
                    </div>

                    <div class="content-card">
                        <h3 class="text-xl font-bold nord-text mb-2">3. 채널링 기반 채팅 시스템</h3>
                        <p class="mb-4 nord-text-dim"><strong>목표:</strong> 전체, 파티, 길드, 귓속말 등 다양한 범위의 채팅을 효율적으로 처리하고, 불필요한 트래픽을 최소화합니다.</p>
                        <h4 class="font-bold nord-accent-green mb-2">구현 방안: ChatManager와 채널 객체 모델</h4>
                        <p class="mb-4 nord-text-dim">`ChatManager`는 여러 개의 `ChatChannel` 객체를 관리합니다. 각 채널은 특정 목적(예: 파티 ID 123번)을 가지며, 해당 채널에 참여한 플레이어들의 목록을 유지합니다.</p>
                        <ul class="list-disc list-inside nord-text-dim space-y-2 text-sm">
                            <li><strong>전체 채널:</strong> 모든 접속 중인 플레이어가 기본적으로 구독합니다.</li>
                            <li><strong>파티/길드 채널:</strong> 플레이어가 파티나 길드에 가입하면, `ChatManager`는 해당 파티/길드 ID를 키로 하는 `ChatChannel`에 플레이어를 등록합니다. 탈퇴 시 채널에서 제거됩니다.</li>
                            <li><strong>귓속말:</strong> 채널을 통하지 않고, `PlayerManager`를 통해 대상 플레이어의 세션을 직접 찾아 메시지를 전송합니다.</li>
                            <li><strong>처리 방식:</strong> 플레이어가 채팅 메시지를 보내면(`S_CHAT` 패킷), `PacketHandler`는 이 패킷을 `ChatManager`의 Job Queue에 넣습니다. `ChatManager`는 채널 종류에 따라 적절한 `ChatChannel`을 찾아, 해당 채널에 속한 모든 플레이어에게 메시지를 전달(`C_CHAT` 패킷)합니다.</li>
                        </ul>
                    </div>
                </div>
            </section>
            
            <section id="plan" class="content-section">
                <h2 class="text-3xl font-bold nord-accent-blue mb-4">상세 개발 계획 (3개월)</h2>
                <p class="text-lg nord-text-dim mb-8">프로젝트를 12주 안에 완료하기 위한 주차별 상세 개발 계획입니다. 각 단계의 목표와 결과물을 명확히 하여 체계적으로 프로젝트를 진행합니다.</p>
                <div class="space-y-8">
                    <div>
                        <h3 class="text-2xl font-bold nord-accent-green mb-4">1개월차: 기반 시스템 구축</h3>
                        <div class="space-y-4">
                            <div class="plan-week"><strong>1주차:</strong><div class="plan-task">프로젝트 환경 설정(CMake), IOCP 기본 모델, Buffer Pool</div></div>
                            <div class="plan-week"><strong>2주차:</strong><div class="plan-task">세션 관리, 패킷 구조 정의, 직렬화(Protobuf) 연동</div></div>
                            <div class="plan-week"><strong>3주차:</strong><div class="plan-task">액터 모델 기반 스레드 모델 설계 (Job, JobQueue), Lock-Free 큐 구현</div></div>
                            <div class="plan-week"><strong>4주차:</strong><div class="plan-task">DB 스키마 설계, DB 비동기 통신 관리자, 로그인/캐릭터 생성 API 구현</div></div>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-2xl font-bold nord-accent-yellow mb-4">2개월차: 핵심 기능 구현</h3>
                        <div class="space-y-4">
                            <div class="plan-week"><strong>5주차:</strong><div class="plan-task">컴포넌트 기반 객체 모델 구현 (Creature, Player, Monster 및 주요 컴포넌트), Object Pool 연동</div></div>
                            <div class="plan-week"><strong>6주차:</strong><div class="plan-task">Quadtree 월드 관리, 캐릭터 이동 동기화 및 AoI 구현</div></div>
                            <div class="plan-week"><strong>7주차:</strong><div class="plan-task">전투 시스템(CombatComponent, 피격 판정 로직), 스킬 데이터 테이블 설계</div></div>
                            <div class="plan-week"><strong>8주차:</strong><div class="plan-task">채팅 시스템(ChatManager), AIComponent를 이용한 몬스터 AI 구현</div></div>
                        </div>
                    </div>
                     <div>
                        <h3 class="text-2xl font-bold nord-accent-red mb-4">3개월차: 콘텐츠 및 안정화</h3>
                        <div class="space-y-4">
                            <div class="plan-week"><strong>9주차:</strong><div class="plan-task">안전한 아이템 거래 로직 구현, InventoryComponent 및 QuestComponent 구현</div></div>
                            <div class="plan-week"><strong>10주차:</strong><div class="plan-task">파티 시스템(Party 객체 및 JobQueue) 구현</div></div>
                            <div class="plan-week"><strong>11주차:</strong><div class="plan-task">성능 프로파일링 및 최적화, 스트레스 테스트, 통합 테스트 및 버그 수정</div></div>
                            <div class="plan-week"><strong>12주차:</strong><div class="plan-task">최종 QA 및 안정화, 서버 배포 스크립트 작성, 포트폴리오 문서 정리</div></div>
                        </div>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const navLinks = document.querySelectorAll('.sidebar-link');
            const sections = document.querySelectorAll('.content-section');
            const defaultSection = 'overview';

            function showSection(sectionId) {
                sections.forEach(section => section.classList.remove('active'));
                const targetSection = document.getElementById(sectionId);
                if (targetSection) targetSection.classList.add('active');
                navLinks.forEach(link => {
                    link.classList.remove('active');
                    if (link.dataset.section === sectionId) link.classList.add('active');
                });
                if (sectionId === 'world' && !document.getElementById('quadtree-canvas').hasChildNodes()) {
                     setTimeout(runSimulation, 50);
                }
                if (sectionId === 'performance' && !Chart.getChart('performanceChart')) {
                    initializePerfChart();
                }
            }

            navLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    showSection(e.target.closest('a').dataset.section);
                });
            });

            showSection(defaultSection);

            const archInfoBox = document.getElementById('architecture-info');
            if (archInfoBox) {
                const archInfoText = archInfoBox.querySelector('p');
                document.querySelectorAll('.clickable-module').forEach(el => {
                    el.addEventListener('click', (e) => {
                        e.stopPropagation();
                        archInfoText.textContent = el.dataset.info;
                        archInfoBox.classList.remove('opacity-0');
                    });
                });
            }
            
            const compInfoBox = document.getElementById('component-info');
            if(compInfoBox) {
                const compInfoText = compInfoBox.querySelector('p');
                document.querySelectorAll('.component-box').forEach(el => {
                    el.addEventListener('click', (e) => {
                        e.stopPropagation();
                        compInfoText.textContent = el.dataset.info;
                        compInfoBox.classList.remove('opacity-0');
                    });
                });
            }

            // --- Quadtree Simulation ---
            const canvas = document.getElementById('quadtree-canvas');
            const simBtn = document.getElementById('quadtree-sim-btn');
            const playerCountSpan = document.getElementById('player-count');
            let quadtree;
            
            class Point { constructor(x, y) { this.x = x; this.y = y; } }
            class Rectangle {
                constructor(x, y, w, h) { this.x = x; this.y = y; this.w = w; this.h = h; }
                contains(point) { return (point.x >= this.x && point.x < this.x + this.w && point.y >= this.y && point.y < this.y + this.h); }
                intersects(range) { return !(range.x > this.x + this.w || range.x + range.w < this.x || range.y > this.y + this.h || range.y + range.h < this.y); }
            }
            class QuadTree {
                constructor(boundary, capacity) { this.boundary = boundary; this.capacity = capacity; this.points = []; this.divided = false; }
                subdivide() {
                    const { x, y, w, h } = this.boundary;
                    const hw = w / 2, hh = h / 2;
                    this.northeast = new QuadTree(new Rectangle(x + hw, y, hw, hh), this.capacity);
                    this.northwest = new QuadTree(new Rectangle(x, y, hw, hh), this.capacity);
                    this.southeast = new QuadTree(new Rectangle(x + hw, y + hh, hw, hh), this.capacity);
                    this.southwest = new QuadTree(new Rectangle(x, y + hh, hw, hh), this.capacity);
                    this.divided = true;
                }
                insert(point) {
                    if (!this.boundary.contains(point)) return false;
                    if (this.points.length < this.capacity) { this.points.push(point); return true; }
                    if (!this.divided) this.subdivide();
                    return this.northeast.insert(point) || this.northwest.insert(point) || this.southeast.insert(point) || this.southwest.insert(point);
                }
                query(range, found = []) {
                    if (!this.boundary.intersects(range)) return found;
                    for (let p of this.points) { if (range.contains(p)) found.push(p); }
                    if (this.divided) { this.northwest.query(range, found); this.northeast.query(range, found); this.southwest.query(range, found); this.southeast.query(range, found); }
                    return found;
                }
                draw(container) {
                    const boundaryDiv = document.createElement('div');
                    boundaryDiv.className = 'quadtree-boundary';
                    Object.assign(boundaryDiv.style, { left: `${this.boundary.x}px`, top: `${this.boundary.y}px`, width: `${this.boundary.w}px`, height: `${this.boundary.h}px` });
                    container.appendChild(boundaryDiv);
                    if (this.divided) { this.northeast.draw(container); this.northwest.draw(container); this.southeast.draw(container); this.southwest.draw(container); }
                }
            }

            function runSimulation() {
                if (!canvas || !document.getElementById('world').classList.contains('active')) return;
                canvas.innerHTML = '';
                const bounds = new Rectangle(0, 0, canvas.clientWidth, canvas.clientHeight);
                quadtree = new QuadTree(bounds, 4);
                const numPlayers = Math.floor(Math.random() * 150) + 50;
                if(playerCountSpan) playerCountSpan.textContent = numPlayers;
                for (let i = 0; i < numPlayers; i++) {
                    const p = new Point(Math.random() * bounds.w, Math.random() * bounds.h);
                    quadtree.insert(p);
                    const pointDiv = document.createElement('div');
                    pointDiv.className = 'quadtree-point';
                    Object.assign(pointDiv.style, { left: `${p.x}px`, top: `${p.y}px` });
                    canvas.appendChild(pointDiv);
                }
                quadtree.draw(canvas);
                let queryRangeDiv = document.createElement('div');
                queryRangeDiv.className = 'query-range';
                canvas.appendChild(queryRangeDiv);
            }

            if(simBtn) simBtn.addEventListener('click', runSimulation);
            
            if(canvas) canvas.addEventListener('mousemove', (e) => {
                if (!quadtree) return;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left, y = e.clientY - rect.top;
                const rangeSize = 80;
                const range = new Rectangle(x - rangeSize / 2, y - rangeSize / 2, rangeSize, rangeSize);
                const queryRangeDiv = canvas.querySelector('.query-range');
                if (queryRangeDiv) {
                    Object.assign(queryRangeDiv.style, { left: `${range.x}px`, top: `${range.y}px`, width: `${range.w}px`, height: `${range.h}px` });
                }

                const pointsInRange = quadtree.query(range);
                canvas.querySelectorAll('.quadtree-point').forEach(p => p.classList.remove('point-in-range'));
                
                if (pointsInRange.length > 0) {
                    const allPointDivs = Array.from(canvas.querySelectorAll('.quadtree-point'));
                    pointsInRange.forEach(p => {
                       for(const div of allPointDivs) {
                           if (Math.abs(parseFloat(div.style.left) - p.x) < 0.1 && Math.abs(parseFloat(div.style.top) - p.y) < 0.1) {
                               div.classList.add('point-in-range');
                               break;
                           }
                       }
                    });
                }
            });

            function initializePerfChart(){
                const canvasElement = document.getElementById('performanceChart');
                if (!canvasElement) return;
                // Check if a chart instance already exists and destroy it.
                let existingChart = Chart.getChart(canvasElement);
                if (existingChart) {
                    existingChart.destroy();
                }

                const ctx = canvasElement.getContext('2d');
                new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['Packet Processing', 'DB Query', 'Pathfinding', 'State Sync'],
                        datasets: [{
                            label: '기본 구현 (Mutex Lock)',
                            data: [120, 200, 350, 90],
                            backgroundColor: 'rgba(191, 97, 106, 0.7)',
                            borderColor: '#BF616A',
                            borderWidth: 1
                        }, {
                            label: '최적화 구현 (Lock-Free)',
                            data: [40, 180, 250, 50],
                            backgroundColor: 'rgba(163, 190, 140, 0.7)',
                            borderColor: '#A3BE8C',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        maintainAspectRatio: false,
                        scales: {
                            y: { beginAtZero: true, grid: { color: '#4C566A' }, ticks: { color: '#D8DEE9', callback: (v) => v + 'μs' }},
                            x: { grid: { display: false }, ticks: { color: '#D8DEE9' }}
                        },
                        plugins: {
                            legend: { labels: { color: '#D8DEE9' }},
                            title: { display: true, text: '최적화 기법에 따른 예상 연산 시간 비교 (마이크로초)', color: '#ECEFF4', font: { size: 16 } }
                        }
                    }
                });
            }
        });
    </script>
</body>
</html>

